[{"content":"Spring Data MongoDB makes it possible to integrate a Spring Boot application with Mongo document database. It provides a MongoRepository containing all the methods used to perform MongoDB CRUD operations.\nBefore we begin, we will need the following:\nPrerequisites JDK installed on your computer.\nYour favorite IDE. I\u0026rsquo;ll be using Intellij IDEA community edition.\nSome knowledge of Java and Spring Boot.\nMongoDB installed on your computer.\nMongoDB terminology Database is a container for collections and can be thought of as a RDBMS database, which is a container for Tables. Collection is equivalent to Tables in RDBMS, but unlike a table, it has a dynamic schema. A collection exists within a database. Document is a single record in a MongoDB collection. It can be thought of as a row in RDBMS. Field this is a document that has zero or more fields. It\u0026rsquo;s like an RDBMS column having a key-value pair. Embedded document is an efficient and clean way to store related data, especially data that are regularly accessed together. Primary key uniquely identifies a document. Creating application We will be using spring initializr to create our application.\nOpen Spring initializr in your browser.\nSelect language to Kotlin.\nAdd Spring Web, Spring Data MongoDB, dependencies.\nLeave other configurations as default and click on generate the project.\nUnzip the downloaded project and open it in your favorite IDE. I\u0026rsquo;ll be using Intelij IDEA community, which is available for free.\nSync the project with maven to download all the dependencies.\nDomain layer In the root package of our application, create a package named domain.\nCreate a Kotlin file named Todo.kt in the domain package we have created above and add the code snippet below into the file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \u0026#34;todo\u0026#34;) data class Todo( @Id val id: String, var title: String, var description: String, var isCompleted: Boolean ) @Document(collection = \u0026quot;todo\u0026quot;) annotation marks the Todo data class as a MongoDB document that will be stored under the todo collection.\n@Id marks the id field as a unique object id in the MongoDB collection.\nController layer In the root package of our application, create a package named controllers.\nCreate a Kotlin file named TodoController.kt and add the code snippet below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @RestController @RequestMapping(\u0026#34;/api/v1/todos/\u0026#34;) @CrossOrigin(\u0026#34;*\u0026#34;) class TodoController(val todoService: TodoService) { //Get all todos in the database @GetMapping(\u0026#34;\u0026#34;) fun getAllTodos(): ResponseEntity\u0026lt;List\u0026lt;Todo\u0026gt;\u0026gt; { return ResponseEntity(todoService.getTodos(), HttpStatus.OK) } //Get Todo from the database by id @GetMapping(\u0026#34;/{id}\u0026#34;) fun getTodoById(@PathVariable(\u0026#34;id\u0026#34;) id: String): ResponseEntity\u0026lt;Todo\u0026gt; { return ResponseEntity(todoService.getTodoById(id), HttpStatus.OK) } //save a todo into the database @PostMapping(\u0026#34;\u0026#34;) fun saveTodo(@RequestBody todo: Todo): ResponseEntity\u0026lt;Any\u0026gt; { return ResponseEntity(todoService.saveTodo(todo), HttpStatus.CREATED) } //update todo @PutMapping(\u0026#34;\u0026#34;) fun updateTodo(@RequestBody todo: Todo): ResponseEntity\u0026lt;Any\u0026gt; { return ResponseEntity(todoService.updateTodo(todo), HttpStatus.OK) } //delete todo @DeleteMapping(\u0026#34;/{id}\u0026#34;) fun deleteTodo(@PathVariable(\u0026#34;id\u0026#34;) id: String): ResponseEntity\u0026lt;Any\u0026gt; { return ResponseEntity(todoService.deleteTodo(id), HttpStatus.NO_CONTENT) } } @CrossOrigin annotation configures the allowed origins. It is also known as cors, cors allows applications to run on different domains to communicate.\n@RestController annotation defines a controller and indicates that the return value of the methods should be bound to the web response body.\n@RequestMapping declares that all APIs URL in the controller will start with /api/v1/todos/.\nRepository layer In the root package of our application create a package named repository and create a Kotlin file named TodoRepository.kt within the repository package, add the code snippet below.\n1 2 3 4 interface TodoRepository : MongoRepository\u0026lt;Todo, String\u0026gt; { } interface TodoRepository extends the MongoRepository interface that contains all the CRUD functions that we are going to use to query our MongoDB collection. Service layer In the root project package, create a package named service and add two Kotlin files TodoService.kt, TodoServiceImpl with the code snippets below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface TodoService { fun saveTodo(todo: Todo) fun getTodos(): List\u0026lt;Todo\u0026gt; fun getTodoById(id: String): Todo fun deleteTodo(id: String) fun updateTodo(todo: Todo) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Service class TodoServiceImpl(val todoRepository: TodoRepository) : TodoService { override fun saveTodo(todo: Todo) { todoRepository.save(todo) } override fun getTodos(): List\u0026lt;Todo\u0026gt; { return todoRepository.findAll() } override fun getTodoById(id: String): Todo { val todoQueried: Optional\u0026lt;Todo\u0026gt; = todoRepository.findById(id) if (todoQueried.isPresent) { return todoQueried.get() } else { throw IllegalStateException(\u0026#34;Todo with id $id not found\u0026#34;) } } override fun deleteTodo(id: String) { todoRepository.deleteById(id) } override fun updateTodo(todo: Todo) { val todoQueried: Optional\u0026lt;Todo\u0026gt; = todoRepository.findById(todo.id) if (todoQueried.isPresent) { val _todo = todoQueried.get() _todo.description = todo.description _todo.isCompleted = todo.isCompleted _todo.title = todo.title todoRepository.save(_todo) } else { throw IllegalStateException(\u0026#34;Todo with id ${todo.id} is not found\u0026#34;) } } } Configurations Connecting to MongoDB locally In the resources directory, open the application.properties file in your IDE and add the configurations below.\n1 2 3 4 spring.data.mongodb.database=todo_db spring.data.mongodb.port=27017 spring.data.mongodb.database=todo_db indicates that our database name is todo_db.\nspring.data.mongodb.port=27017 indicates that we will be connecting to mongodb through port 27017.\nConnecting to Mongo Atlas\nVisit Mongo Atlas and create an account.\nClick on the Database Access side menu and add a database user.\nClick on the Cluster side menu and create a database. On the Cluster side menu, click on connect and select the connection method as connect your application. Copy the connection string. Add configurations below to the application.properties file. 1 2 3 4 5 6 #spring.data.mongodb.database=todo_db #spring.data.mongodb.port=27017 spring.data.mongodb.uri=mongodb+srv://\u0026lt;username\u0026gt;:\u0026lt;password\u0026gt;@cluster0.vlohf.mongodb.net/\u0026lt;database\u0026gt;?retryWrites=true\u0026amp;w=majority Change \u0026lt;username\u0026gt;, \u0026lt;password\u0026gt;, and \u0026lt;database\u0026gt; to the credentials you have created in Mongo Atlas. Conclusion You have now learned how to create a Spring Boot CRUD API in Kotlin and MongoDB, add fields dateCreated and lastModified in the Todo data class.\nYou can find the source code here.\nHappy coding.\n","date":"2022-06-05T00:00:00Z","image":"/p/spring-data-mongodb/cover_hu3716021536e81eaadfcad5b8aa7a543a_90537_120x120_fill_q75_box_smart1.jpeg","permalink":"/p/spring-data-mongodb/","title":"Getting started with Spring Data MongoDB in Kotlin"},{"content":"A notification is a message widget that is displayed outside the applications user interface. When a notification is issued, it appears as an icon in the notification area. To view the details of the notification, the user opens the notification drawer.\nAndroid notifications Prerequisites To follow this tutorial along ensure you have the following:\nAndroid Studio installed on your computer. Some knowledge of Kotlin programming language. Some knowledge of Android app development. Application setup Start Android studio and create a new Android project with an empty activity template.\nCreating and sending notifications Basic notification Create a function with the name basicNotification. The function created above should have the code snippets below. The function creates a basic notification with an icon, title, and notification content. 1 2 3 4 5 6 7 8 9 10 private fun basicNotification() { val builder = NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\u0026#34;Test notification\u0026#34;) .setContentText(\u0026#34;Test Notification body\u0026#34;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) with(NotificationManagerCompat.from(this)) { notify(notificationId, builder.build()) } } From the above code snippet:\nNotificationCompat.Builder(this, CHANNEL_ID) takes in the context and the channel id. Channel id is required for notifications to work on Android 8.0 and later versions, channel id is used to manage notifications on the later Android versions. setSmallIcon(R.drawable.notification_icon) sets the notification icon that appears on the notification drawer. setContentTitle(textTitle) sets the title of the notification that is shown on the notification drawer. setContentText(textContent) sets the body of the notification. setPriority(NotificationCompat.PRIORITY_DEFAULT) sets how the Android system will notify the user of the notification based on the priority set, it works on Android 7.0 and below. The code snippet below creates and shows the notification in the systems notification drawer. 1 2 3 with(NotificationManagerCompat.from(this)) { notify(notificationId, builder.build()) } Pending intent notification It is possible to add an intent to a notification such that whenever a user clicks on the notification it opens up an activity or fragment from a pending intent. To create a notification with a pending intent, create a function with the name pendingNotification in the MainActivity.kt and add the code snippet below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private fun pendingNotification() { val intent = Intent(this, MainActivity::class.java).apply { flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK } val pendingIntent: PendingIntent = PendingIntent.getActivity(this, 0, intent, 0) val builder = NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\u0026#34;My notification\u0026#34;) .setContentText(\u0026#34;Hello World!\u0026#34;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setContentIntent(pendingIntent) .setAutoCancel(true) with(NotificationManagerCompat.from(this)) { notify(notificationId, builder.build()) } } The minor snippet below creates a pending intent that gets executed whenever the notification is clicked. 1 2 3 val intent = Intent(this, MainActivity::class.java).apply { flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK } .setContentIntent(pendingIntent) attaches the pending intent created to the notification, this makes it possible for the notification to handle the pending intent operation. Notification with action button Android system makes it possible to perform certain operations through notification action buttons i.e receive an incoming call, snooze an alarm through the notification buttons.\nNotification actions were introduced with Android version 5.0, that\u0026rsquo;s the reason why we will annotate the function actionNotification with the @RequiresApi(Build.VERSION_CODES.O) annotation.\nCreate a function with the name actionNotification and add the code snippets below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RequiresApi(Build.VERSION_CODES.O) private fun actionsNotification() { val snoozeIntent = Intent(this, MyBroadCastReceiver::class.java).apply { action = \u0026#34;snooze\u0026#34; putExtra(EXTRA_NOTIFICATION_ID, 0) } val snoozePendingIntent: PendingIntent = PendingIntent.getBroadcast(this, 0, snoozeIntent, 0) val builder = NotificationCompat.Builder(this, CHANNEL_ID) .setSmallIcon(R.mipmap.ic_launcher) .setContentTitle(\u0026#34;My notification\u0026#34;) .setContentText(\u0026#34;Hello World!\u0026#34;) .setPriority(NotificationCompat.PRIORITY_DEFAULT) .setContentIntent(snoozePendingIntent) .addAction( R.drawable.ic_baseline_alarm_off_24, \u0026#34;Snooze\u0026#34;, snoozePendingIntent ) with(NotificationManagerCompat.from(this)) { notify(notificationId, builder.build()) } } To perform an action from the notification, we will create a new kotlin class with the name MyBroadCastReceiver. MyBroadCastReceiver class extends the BroadCastReceiver interface and implements the onReceive() method of the BroadCastReceiverinterface.\nNotification channel Android version 8.0 and later versions require the notification channel for notification to be displayed on the notifications drawer.\nIt is through notification channels that the Android operating system manages notifications. Create a function with the name createNotificationChannel() in the MainActivity and add the code snippets below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 private fun createNotificationChannel() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val name = \u0026#34;test_notification\u0026#34; val descriptionText = \u0026#34;test_notification_description\u0026#34; val importance = NotificationManager.IMPORTANCE_DEFAULT val channel = NotificationChannel(CHANNEL_ID, name, importance).apply { description = descriptionText } val notificationManager: NotificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager notificationManager.createNotificationChannel(channel) } } BroadCastReceiver In the project package, create a kotlin class with the name MyBroadCastReceiver and add the code snippets below.\n1 2 3 4 5 6 7 8 9 import android.content.BroadcastReceiver import android.content.Context import android.content.Intent class MyBroadCastReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { //Action to be perfomed placed here context?.startActivity(intent) } } In the oncreate() function of the MainActivity add the code snippet below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) createNotificationChannel() btnShowNotification = findViewById(R.id.btnShowNotification) btnShowPendingNotification = findViewById(R.id.btnShowPendingNotification) btnShowActionNotification = findViewById(R.id.btnShowActionNotification) btnShowNotification.setOnClickListener { basicNotification() } btnShowPendingNotification.setOnClickListener { pendingNotification() } btnShowActionNotification.setOnClickListener { //Checks the android version if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { actionsNotification() } } } User interface In the activity_main.xml file add the code snippet below. There are three buttons in the XML design below. The first button fires up the basic notification, the second button fires up the pending intent notification, and the last button fires the action button notification.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btnShowNotification\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Show Basic Notification\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/btnShowPendingNotification\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btnShowPendingNotification\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Show Pending Intent Notification\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/btnShowActionNotification\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/btnShowNotification\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btnShowActionNotification\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Show Action Notification\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/btnShowPendingNotification\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Conclusion Now that you understand how notifications work, implement a push notification using firebase cloud messaging. Full source code for the application we have built can be downloaded from here.\nTo read more on the notification anatomy visit the Android documentation.\nHappy coding.\n","date":"2022-06-04T00:00:00Z","image":"/p/android-notifitions/hero_huf0ddc0edf9c3a783b6694c62278b7f93_32245_120x120_fill_q75_box_smart1.jpeg","permalink":"/p/android-notifitions/","title":"Getting Started with Android Notifications"}]